# Extensions

## 1. Nesting
Sass의 유용한 확장 기능으로 중첩(Nestung)이 있다. CSS는 자식요소를 선택하여 선언하는 경우 부모 요소를 기술하여야 한다.  

```css

.container {
  width: 100%;
}

.container h1 {
  color: red;
}
```

하지만 Sass는 Nesting으로 표현할 수 있다.

```scss
.container {
  width: 100%;
  h1 {
    color: red;
  }
}
```

부모요소의 참조가 필요한 경우 `&`를 사용한다. 예를 들어 `:hover` 또는 `:before` 등의 가상 클래스 선택자(Pseudo-Class Selector)를 지정하는 경우 부모요소의 참조가 필요하다.

```scss
a.myAnchor {
  color: blue;
  &:hover {
    text-decoration: underline;
  }
  &:visited {
    color: purple;
  }
}
```

Nesting은 프로퍼티에도 사용할 수 있다.

```scss
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
```

위 코드의 컴파일 결과는 아래와 같다.

```css
.funky {
  font-family: fantasy;
  font-size: 30em;
  font-weight: bold;
}
```

## 2. @-Rules and Directives

### 1) @import

1개의 CSS파일에 모든 스타일을 기술하는 것은 가독성을 나쁘게 한다. 또한 기능에따라 CSS파일을 분리하면 재사용 및 유지보수 측면에서 유리하다. 따라서 룰을 정하여 파일을 분리하여 개발하는 것은 효과적인 방법이다.

Sass는 @import directive를 사용하여 분리된 stylesheet 파일을 import할 수 있다. 기존의 CSS @import보다 편리한 기능을 제공한다.

```scss
@import "foo.scss";

//확장자는 생략 가능하다.
@import "foo";

//import multiple files
@import "rounded-corners", "text-shadow";

$family: unquote("Droid+Sans");
@import url("https://fonts.googleapis.com/css?family=#{$family}")
```

여러개의 파일로 분할하는 것 또는 분할된 파일을 **partial**이라 하며 partial된 Sass 파일명의 선두에는 underscore(_)를 붙인다. (_reset.scss, _module.scss, _print.scss)

예를 들어 "_foo.scss"라는 partial된 Sass 파일이 있고 이 파일을 import 하는 경우 아래와 같이 기술한다. 파일명 선두의 _와 확장자는 생략할 수 있다.

```sass
@import "foo";
```

partial된 Sass 파일명 선두에 붙인 _의 의미는 import는 수행하되 CSS로의 컴파일은 수행하지 말라는 의미를 갖는다. 따라서 partial은 import시에는 CSS파일로 컴파일되지 않기 때문에 최종적으로 CSS로 컴파일을 수행할 Sass 파일에서 import한다. 

![partial](http://poiemaweb.com/img/partial.png)  

@import는 top-level에서 사용하는 것이 일반적이지만 CSS rule 또는 @media rule 내에 포함시키는 것도 가능하다.

```scss
//_example.scss
.example {
  color: red;
}
```

```scss
#main {
  @import "example";
}
```

위 코드는 컴파일 결과는 아래와 같다.

```css
#main .example {
  color: red;
}
```

### 2) @extend

기존 스타일을 상속하고자 경우 @extend를 사용한다.

```html
<div class="error seriousError">
  Oh no! You've been hacked!
</div>
```
기존에 선언되어 있는 error class를 사용하면서 일부 rule set에 대해서는 다른 선언이 필요한 경우 자주 사용하는 방법이다.

이러한 경우 사용할 수 있는 방법이 상속이다. 상속되는 rule set을 그대로 상속받아 다른 부분만 별도 선언하면 된다.

```scss
.error {
  border: 1px #f00;
}

.seriousError {
  @extend .error;

  border-width: 3px;
  border-color: darkblue;
}
```
위 코드의 컴파일 결과는 아래와 같다. `.error`과 `.seriousError`가 공통으로 사용하는 프로퍼티를 묶어 합리적인 룰셋을 생성한다.

```css
.error, .serousError {
  border: 1px #f00;
  background-color: blue;
}

.seriousError {
  border-width: 3px;
  border-color: darkblue;
}
```

이제 하나의 클래스만 적용시키면 된다.

```html
<div calss="seriousError">
  Oh no! You've been hacked!
</div>
```

@extend를 @media블록과 같이 사용하는 경우, 제대로 작동하지 않는다. 다시말해 @media 안에서 외부 선택자를 @extend할 수 없다.

```scss
.foo {
  color: red;
}

@media print {
  .bar {
    //ERROR
    @extend .foo;
  }
}
```

> 컴파일 후 자신의 셀렉터가 어디에 첨부될 것인지 에상하기 어렵고, 예상치 못했던 부작용이 발생할 수 있다. 따라서 @Extend의 사용은 가급적 자제하고 Mixin을 사용하는 것을 추천한다.  

[@extend의 부작용](https://sass-guidelin.es/ko/#extend)

### 3) Placeholder Selectors

Placeholder Selector는 Sass3.2부터 제공되는 기능으로 재이용 가능한 Rule set을 %키워드로 지정하는 @extend 전용 Selector이다.

Placeholder Selector는 상속만을 위한 rule set으로 자신은 컴파일되지 않는다.

```scss
%input-style {
  font-size: 14px;
}

.input-black {
  @extend %input-style;

  colr: black;
}

.input-red {
  @extend %input-style;

  color: red;
}
```

컴파일 결과는 아래와 같다.

```css
.input-black, .input-red {
  font-size: 14px;
}

.input-black {
  color: black;
}

.input-red {
  color: red;
}
```

## 3. 조건과 반복

Sass는 Javascript 같은 프로그래밍 언어와 같이 제어문(Control flow statement)을 사용할 수 있는 기능을 제공한다.

### 1) if()

built-in if()함수는 주어진 조건읊 판단하여 결과를 리턴한다. Javascript의 삼항 연산자와 유사하게 동작한다.

```scss
if(condition, if_true, if_false)
```

condition이 true이면 if_true를, false이면 if_false를 반환한다.

```scss
$type: ocean;

p {
  color: if($type == ocean, blue, black); // color: blue;
}
```

### 2) @if

@if를 사용하면 조건분기가 가능하다.

```scss
$type: monster;

p {
  @if $type == ocean {
    color: blue;
  } @else if $type == matador {
    color: red;
  } @else if $type == monster {
    color: green;
  } @else {
    color: black;
  }
}
```

컴파일 결과는 아래와 같다.

```css
p {
  color: green;
}
```

### 3) @for

@for으로 반복문을 사용할 수 있다.

```scss
@for $i from 1 though 3 {
  .item-#{$1} { width: 2em * $i; }
}
```

컴파일 결과는 아래와 같다.

```css
.item-1 {
  width: 2em;
}
.item-2 {
  width: 4em;
}
.item-3 {
  width: 6em;
}
```

###