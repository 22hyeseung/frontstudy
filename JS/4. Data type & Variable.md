# Data type & Variable

변수는 위치(주소)를 기억하는 저장소이다. 위치란 메모리 상의 주소(adderss)를 의미한다. 즉 변수란 메모리 주소(memory address)에 접근하기 위해 사람이 이해할 수 있는 언어로 지정한 식별자이다.

시스템 별로 데이터 따라 확보해야 할 메모리의 크기가 달라야 한다. 가장 좋은 것은 데이터 용량에 딱 맞는 메모리 저장 공간을 확보하는 것인데, 그렇기 위해서는 대부분의 언어가 정적 타이핑을 택하고 있지만, **자바스크립트의 경우 쉬운 언어를 지향하기 때문에 동적 타이핑을 채택하고 있다.**

# 1. 자료형 Data type

* 기본자료형
* 객체형

## 1) 기본자료형
변경 불가능한 값이다.

* ***Boolean***

* ***null***

* ***undefined***

* ***숫자 Number***  
양의 정수, 음의 정수, 실수 등을 표현하며 추가적으로 세가지 의미있는 기호적인 값들도 표현 가능하다.  
  * +/-  infinity
  양의 무한대/음의 무한대
  * NaN(not-a-number)
  0으로 나누거나 문자열로 연산하는 경우 자바스크립트는 연산을 수행하기는 하지만, NAN을 표시한다.

* ***문자열 String***  
  문자열 타입은 텍스트 데이터를 나타내는데 사용한다. 이는 0개 또는 그 이상의 
  유니코드(다국어를 지원하는 문자 포맷, 16비트 부호없는 정수 값) 문자들의 집합이다. 문자열은 홑따옴표(') 또는 쌍따옴표(") 안에 텍스트를 넣어 생성한다.
  
  >자바스크립트의 기본은 홑따옴표(')이다. 물론 쌍따옴표(")도 사용이 가능하다. 하지만
  소스코드를 작성할 때는 되도록 섞어쓰지 않고 통일감 있게 작성한다.

  문자열은 배열처럼 인덱스를 통해 접근할 수 있다. 이미 생성된 문자열에는 새로운 문자를 대입하여 변경하려해도 반영되지 않는다. (하지만, 에러는 발생하지 않는다.) 한번 생성된 문자열은 read only로 수정이 불가하다. 이를 변경 불가능(immutable)이라 한다.

  새로운 문자열을 할당하는 것은 물론 가능하다. 이는 기존에 할당된 문자열 데이터 자체를 변경하는 것이 아니라, 메모리상에 새로운 문자열을 생성하여 그 새로운 문자열을 할당하는 것이다. 즉, 주소만 바꿔주는 것이다. 

* ***Symbol***
  ES6에서 추가된 7번째 타입

## 2) 객체형(Object type, 참조형)
객체 내부에는 데이터도 있고 함수도 있다. 객체 내부에 있는 데이터를 메서드들이 조작해서 어떤 작업을 하는 것이다. 다른 것들과 분리해서 비슷한 일을 하는 것들을 하나로 묶어두는 개념이다. 객체는 데이터(프로퍼티)가 있고 데이터와 관련된 동작(메서드)으로 이루어져 있다.
엄밀히 말하면 메서드도 객체이다. 프로퍼티의 값이 함수이면 메서드라고 한다. 아래는 전부 객체이다.
* 함수(Function)
* 배열
* 날짜(날짜는 생성자 함수를 제공한다.)
* 정규식(문자열중에서 일부를 주어서 그 문자열과 일치하는지? 혹은 흡사 셀럭터 사용처럼 어떤 문자로 시작하는 것을 찾아온다던가 하는 것들도 전부 정규식이다.)

# 2. 변수 (Variable)

```naming```
변수명은 다른 사용자가 변수의 존재 목적을 쉽게 이해할 수 있도록 의미있는 이름을 지정해야 한다.

변수는 휘발성 데이터가 아니다. 값을 유지할 필요성이 있을 때 사용한다. 따라서 저장기능도 있으며 필요할 때 가져올 수 있어야 한다. 저장한 기능을 가져오는 것을 ```참조한다.```라고 이야기 한다. 이는 메모리에 있는 데이터를 변수명을 가지고 꺼내오는 것을 의미한다.

변수명은 명명 규칙이 존재한다.
* 첫 문자는 반드시 영문자로 시작한다. 또한 자바스크립트는 대문자와 소문자를 구별한다. 따라서 변수명의 첫 문자는 영문 대문자와 소문자 모두 올 수 있으며  _, $도 올 수 있다.
$마크는 중요한 변수에 주로 붙인다.
* 두번째 문자부터는 숫자도 올 수 있다.

변수를 선언하는 유일한 방법은 var키워드를 사용하는 것이다. 등호(=, equal sign)는 변수에 값을 할당하기 위해 사용된다. 변수는 오른쪽에서 왼쪽으로 할당한다.  
```javascript
var name;     // 변수 name 선언
name = 'Lee'; // 변수 name에 값 'Lee'가 저장(할당)되었다.

var age = 30; // 선언과 할당
//선언과 할당이 동시에 이루어지면 메모리에 무리가 갈 수 있어 eslint에서는 원인으로 붉은 줄을 표시한다.

var person = 'Lee',
    address = 'Seoul',
    price = 200;

/* 콤마(,)를 이용해 다수의 변수를 한번에 선언할수도 있다.
하지만 되도록 하나씩 선언하는 것이 좋다. */

var price = 10;
var tax   = 1;
var total = price + tax;
```

값을 할당하지 않은 변수 즉 선언만 되어 있는 변수는 undefined로 초기값을 갖게 된다. 미선언 변수에 접근하면 ReferenceError 예외가 발생한다.

```javascript
var x; 
console.log(x); // undefined: 선언했지만 값을 할당하지 않은 변수
console.log(y); // ReferenceError: 선언하지 않은 변수를 참조하려할 때 발생하는 에러
``` 
x변수를 선언하고, 메모리 공간에 undefined를 넣어둔다. 왜 그럴까? 선언 이후 할당을 하지 않으면 타 언어의 경우 문제가 발생할 소지가 있다. 변수를 선언하면 공간을 확보하기 마련인데, 그 메모리 공간이 비어있을 거라는 확신이 없다. 즉 쓰레기 값이 들어있을 수 있다. 따라서 값을 할당하지 않아도 값이 존재할 수 있다는 말이다. 따라서 선언과 동시에 변수에 할당된 메모리를 초기화하는 과정을 거친다. 자바스크립트에서는 선언만 하고 값이 할당되지 않았을 때는, 자동으로 초기화한 후 그 자리에 undefined라는 값을 할당해두는 것이다. 하지만 되도록 변수를 선언하면 그대로 두지 않고, 값을 할당 해주는 것이 좋다.

ReferenceError는 선언하지 않은 변수를 참조하려할 때 발생하는 에러이다. 이는 심각한 문제이기 때문에 관대한 자바스크립트 언어도 에러로 표시한다.

## 1) 변수의 중복 선언
변수는 중복 선언이 가능하다.
```javascript
var x = 1;
console.log(x); // 1

// 변수의 중복 선언
var x = 100;
console.log(x); // 100
```
하지만 중복 선언은 문법적으로 허용되지만 의도치 않게 변수 값을 변경할 수 있으므로 사용하지 않는 것이 좋다.

## 2) 변수 선언시 var 키워드 생략 허용
var키워드를 생략할 수 있다.
```javascript
x = 1;
console.log(x); // 1
```
var 키워드의 생략은 문법적으로 허용되지만 의도하지 않게 **변수를 전역화할 수 있으므로**사용하지 않는 것이 좋다.

## 3) 동적 타이핑(Dynamic Typing)  
타이핑(Typing)이란 데이터의 타입을 정하는 것을 의미한다. 타입에 관계 없이 모든 자료형에 var 키워드를 사용하지만, 사실 자바스크립트 엔진은 할당되는 데이터를 보고, 스스로 데이터 타입을 판단한다. 이를 동적 타이핑이라고 한다.

JavaScript는 동적 타입(dynamic typed) 언어 혹은 느슨한 타입(loosely type) 언어이다. 이것은 변수의 Type annotation이 필요 없이 값이 할당되는 과정에서 자동으로 자료형이 결정(Type Inference)될 것이라는 뜻이다. 따라서 동적타이핑은 아래 예제처럼 같은 변수에 여러 data type의 값을 대입할 수 있다는 편리성이 존재한다. 하지만 이는 별로 좋은 방식은 아니다. 변수는 한번만 사용하는 것이 좋다.

>동적타이핑은 편리하긴 하지만 반드시 좋은 것은 아니다. 오히려 불편한 상황이 발생할 수 있다. 게다가 동적타이핑은 컴파일 단계에서 에러를 거의 배출하지 않지만 런타임 에러 발생이 잦다. 대규모 프로젝트의 경우 이는 심각한 문제가 될 수 있다. 이를 보완하여 나온 언어가 TypeScript이다.

```javascript
var foo;

console.log(typeof foo);  // undefined

foo = null;
console.log(typeof foo);  // object

foo = {};
console.log(typeof foo);  // object

foo = 3;
console.log(typeof foo);  // number

foo = 3.14;
console.log(typeof foo);  // number

foo = 'Hi';
console.log(typeof foo);  // string

foo = true;
console.log(typeof foo);  // boolean
```

## 5. 변수 호이스팅(Variable Hoisting)
[참고](http://www.nextree.co.kr/p7363/)

```javascript
console.log(foo); // ① undefined
var foo = 123;
console.log(foo); // ② 123
{
  var foo = 456;
}
console.log(foo); // ③ 456
```

var 키워드를 사용하여 선언한 변수는 중복 선언이 가능하기 때문에 위의 코드는 문법적으로 문제가 없다.

①에서 변수 foo는 아직 선언되지 않았으므로 ReferenceError: foo is not defined가 발생할 것을 기대했겠지만 콘솔에는 undefined가 출력된다.

이것은 다른 C-family 언어와는 차별되는 자바스크립트의 특징으로 모든 선언문은 호이스팅(Hoisting)되기 때문이다.

**호이스팅이란 var 선언문이나 function 선언문을 해당 Scope의 선두로 옮기는 것을 말한다.** 즉 자바스크립트는 코드를 실행하기 전에 var 선언문과 function 선언문을 해당 [스코프](http://poiemaweb.com/js-scope)의 맨위로 옮긴다.(사실 실제로 옮기는 것은 아니고 옮겨진 것 처럼 행동하는 것이다.)

변수가 어떻게 생성되며 호이스팅은 어떻게 이루어지는지 좀더 자세히 살펴보자. 변수는 3단계에 걸쳐 생성된다. 자세한 내용은 [Execution Context](http://poiemaweb.com/js-execution-context)을 참조하기 바란다.

변수가 어떻게 생성되는지에 대해 자세히 알아본다. 본래 변수는 3단계에 의해 만들어진다.  

1) 선언 단계

2) 초기화 단계

3) 할당 단계

![변수3단계](http://poiemaweb.com/img/var-lifecycle.png)

코드를 실행하기 위해서는 변수가 있고 그 값이 123임을 자바스크립트 엔진이 알아야 한다. 그 정보를 갖고 있는 것이 **변수 객체**라는 것이다.  
선언단계에서는 변수 객체에 변수를 등록한다.
초기화단계에서는 등록된 변수를 메모리에 할당하고 초기화한다.
할당단계에서는 실제값을 할당한다.

var 키워드로 선언한 변수는 1단계와 2단계가 동시에 이루어진다.
자바스크립트에서는 변수 선언문으로 선언과 초기화를 한번에 수행한다. 따라서 console.log(foo); 명령을 수행하면 변수 호이스팅에 의해 var foo;가 변수 선언문 앞으로 옮겨진다. 해당 변수에 대한 변수 선언과 초기화가 동시에 이루어진 후 초기화된 상태(undefined)의 변수가 console.log();명령에 의해 콘솔창에 출력된 것이다. foo 변수가 실제 값을 갖게 되는 시점은 할당 받는 것은 할당문을 만났을 때이다. 그 이전까지는 계속 undefined이다.

JavaScript의 변수는 다른 C-family와는 달리 block-level scope를 가지지 않고 ***function-level scope*** 를 갖는다. 단, ECMAScript 6에서 도입된 let, const 키워드를 사용하면 block-level scope를 사용할 수 있다. 자세한 내용은 [Scope](http://poiemaweb.com/js-scope)를 참조하기 바란다.

---
Function-level scope  
함수 내에서 선언된 변수는 함수 내에서만 유효하며 함수 외부에서는 참조할 수 없다. 즉, 함수 내부에서 선언한 변수는 지역 변수이며 함수 외부에서 선언한 변수는 모두 전역 변수이다.

Block-level scrope
코드 블럭 내에서 선언된 변수는 코드 블럭 내에서만 유효하며 코드 블럭 외부에서는 참조할 수 없다.
---

## 6. var 키워드로 선언된 변수의 문제점

ES5에서 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이다. var 키워드로 선언된 변수는 아래와 같은 특징을 갖는다. 이는 다른 C-family 언어와는 차별되는 특징(설계상 오류)으로 주의를 기울이지 않으면 심각한 문제를 발생시킨다.

  1) Function-level scope  
    전역 변수의 남발
    for loop 초기화식에서 사용한 변수를 for loop 외부 또는 전역에서 참조할 수 있다.

  2) var 키워드 생략 허용  
    의도하지 않은 변수의 전역화

  3) 중복 선언 허용  
    의도하지 않은 변수값 변경

  4) 변수 호이스팅  
    변수를 선언하기 전에 참조가 가능하다.

대부분의 문제는 전역 변수로 인해 발생한다. 전역 변수는 간단한 애플리케이션의 경우, 사용이 편리한 면이 있지만 불가피한 상황을 제외하고 사용을 억제해야 한다. 전역 변수는 범위(scope)가 넓어서 어디에서 어떻게 사용될 지 파악하기 힘들다. 이는 의도치 않은 변수의 변경이 발생할 수 있는 가능성이 증가한다. 또한 여러 함수와 상호 의존하는 등 side effect가 있을 수 있어서 복잡성이 증가한다.

변수의 범위(scope)는 좁을수록 좋다.

ES6는 이러한 var의 단점을 보완하기 위해 let과 const 키워드를 도입하였다.