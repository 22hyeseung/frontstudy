CSS Basic
---
_2017.07.24: Week2_

### 8. Position
###### 요소의 위치를 지정하는 레이아웃의 기본

#### 8.1 position 프로퍼티
```position``` 프로퍼티는 요소의 위치를 정의하는 것이다. 위/아래/왼쪽/오른쪽으로 얼만큼 갈지를 top/bottom/left/right 프로퍼티로 함께 정의한다. 따라서 top ~ right 요소는 px값을 갖는다.  

ex. ```top: 100px```: 위(top)에서부터 100px 떨어진 곳

![position](http://poiemaweb.com/img/position.png)


요소는 기본적으로 부모의 좌상(left-top)에 위치한다.
부모 요소가 자리를 옮기면, 자식 요소도 자리를 따라 옮긴다.

#### 1) static: 기본 위치
기본적인 요소의 배치 순서에 따라 배치된다.
부모 요소가 있는 자식 요소인 경우에는 부모 요소의 위치를 기준으로 배치된다.
이미 설정된 position을 무력화할 때 사용하기도 하지만, 거의 사용할 일이 없다. 좌표 프로퍼티를 같이 사용할 수 없으며(기본 위치로 배치되므로) 사용하는 경우 무시된다.

```
<!DOCTYPE html>
<html>
<head>
  <style>
    body { margin: 0; }
    .parent {
      width: 150px;
      height: 150px;
      background: #bcbcbc;
      border: 1px solid #bcbcbc;
    }
    .static-box {
      position: static;
      background: #2E303D;
      color: #e55c3c;
      font-weight: bold;
      text-align: center;
      line-height: 150px;
    }
  </style>
</head>
<body>
  <div class="parent">
    <div class="static-box">static box</div>
  </div>
</body>
</html>

```

#### 2) relative: 상대 위치

```
<!DOCTYPE html>
<html>
<head>
  <style>
    body { margin: 0; }
    .parent {
      width: 150px;
      height: 150px;
      background: #bcbcbc;
      border: 1px solid #bcbcbc;
      margin: 50px;
    }
    .relative-box {
      position: relative;
      top: 50px; left: 50px;
      background: #2E303D;
      color: #e55c3c;
      font-weight: bold;
      text-align: center;
      line-height: 150px;
    }
  </style>
</head>
<body>
  <div class="parent">
    <div class="relative-box">relative box</div>
  </div>
</body>
</html>
```

#### 3) absolute: 절대 위치
부모 요소를 기준으로 좌표 프로퍼티만큼 움직인다.  
* 부모 또는 조상이 static인 것은 무시한다.  
* 부모나 조상 요소 중 static을 갖지 않는 요소를 기준으로 움직인다. static이 아닌 요소가 다수라면 가장 가까운 부모를 기준으로 움직인다.  
* 만약 모든 부모와 조상이 static을 가지고 있다면 body를 기준으로 한다.
> ***relative와 absolute의 활용방식***  
특정 요소를 움직이고자 할 때는 absolute를 사용하는 경우가 많다. 움직이고자 하는 요소의 기준이 되는 부모에 relative를 주고 움직이려는 요소에 absolute를 주어서 그 요소를 이동시키는 방식이다.

> ***static VS absolute***  
static은 기본 위치를 기준으로 하지만, absolute는 부모 요소를 기준으로 한다.

> ***relative VS absolute***  
relative는 부모를 기준으로 움직이지만, absolute는 static이 아닌 부모를 기준으로 한다. **기본적으로 특정 요소를 움직이고자 할 때는 absolute를 사용해야 한다!!**

```
<!DOCTYPE html>
<html>
<head>
  <style>
    body { margin: 0; }
    .parent {
      width: 200px;
      height: 200px;
      background: #bcbcbc;
      border: 1px solid #bcbcbc;
      margin: 50px 0 0 300px;
      position: relative;
    }
    .absolute-box {
      position: absolute;
      height: 200px; width: 200px;
      top: 50px; left: 50px;
      color: #e55c3c;
      font-weight: bold;
      text-align: center;
      background: #2E303D;
      line-height: 200px;
    }
  </style>
</head>
<body>
  <div class="parent">
    <div class="absolute-box">absolute box (in parent)</div>
  </div>
  <div class="absolute-box">absolute box (no parent)</div></body>
</html>
```

```
<!DOCTYPE html>
<html>
<head>
  <style>
    body { margin: 0;}
    .parent {
      width: 150px;
      height: 150px;
      background: #bcbcbc;
      border: 1px solid #bcbcbc;
      margin: 50px;
      float: left;
      /*position: relative;*/
    }
    .relative-box {
      position: relative;
      top: 10px; left: 10px;
      width: 150px;
      height: 150px;
      background: #2E303D;
      color: #e55c3c;
      font-weight: bold;
      text-align: center;
      line-height: 150px;
    }
    .absolute-box {
      position: absolute;
      top: 10px; left: 10px;
      width: 150px;
      height: 150px;
      background: #2E303D;
      color: #e55c3c;
      font-weight: bold;
      text-align: center;
      line-height: 150px;
    }
  </style>
</head>
<body>
  <div class="parent">
    <div class="absolute-box">absolute box</div>
  </div>
  <div class="parent">
    <div class="relative-box">relative box</div>
  </div>
</body>
</html>
```

#### 4) fixed: 고정 위치
브라우저의 viewport를 기준으로 좌표프로퍼티를 사용하여 위치를 이동시킨다. 스크롤이 되더라도 화면에서 사라지지 않고 항상 같은 곳에 위치한다. (화면에 스티커를 붙인 것과 같은 효과)  
fixed 프로퍼티 선언 시, block 요소의 width는 inline 요소와 같이 content에 맞게 변화되므로 적절한 width를 지정하여야 한다.
```
<!DOCTYPE html>
<html>
<head>
  <style>
    body { margin: 0; }
    .fixed-box {
      position: fixed;
      color: #e55c3c;
      font-weight: bold;
      text-align: center;
      background: #2E303D;
    }
    .sidebar {
      width: 50px;
      height: 100%;
      top: 0;
      right: 0;
      padding-top: 100px;
    }
    .footer {
      width: 200px;
      width: 100%;
      height: 50px;
      bottom: 0;
      left: 0;
      line-height: 50px;
    }
  </style>
</head>
<body>
  <div class="fixed-box sidebar">fixed box (side-bar)</div>
  <div class="fixed-box footer">fixed box (footer)</div>
</body>
</html>
```

#### 8.2 z-index 프로퍼티
기본적으로 요소는 먼저 선언한 요소가 나중 선언한 요소보다 아래에 오게 된다. 즉, 가장 마지막에 선언한 요소가 가장 위에 오게 된다.
z-index 프로퍼티는 이 순서를 제어할 수 있다.
z-index 프로퍼티에 숫자값을 부여함으로써 순서를 정하는 것으로, 큰 숫자값을 지정할수록 더 앞에 출력된다.
```
<!DOCTYPE html>
<html>
<head>
  <style>
    .box {
      width: 100px; height: 100px;
      position: absolute;
    }
    .red {
      background-color: red;
      left: 10px; top: 10px;
      z-index: 100;
    }
    .green {
      background-color: green;
      left: 50px; top: 50px;
      z-index: 10;
    }
    .blue {
      background-color: blue;
      left: 90px; top: 90px;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div class="box red"></div>
  <div class="box green"></div>
  <div class="box blue"></div>
</body>
</html>
```

#### 8.3 overflow 프로퍼티
자식요소가 부모요소의 영역을 벗어나는 경우가 발생할 수 있다. 자식요소의 컨텐츠가 부모요소의 영역보다 많아 흘러 넘치는 경우이다.  
***property value***
* visible(default): 영역을 벗어난 부분을 표시한다. (기본값)
* hidden: 영역을 벗어난 부분을 잘라내어 보이지 않게 한다.
* scroll: 영역을 벗어난 부분이 없어도 스크롤 표시한다.(현재 대부분 브라우저는 auto과 동일하게 작동한다)
* auto: 영역을 벗어난 부분이 있을때만 스크롤 표시한다.

***

### 9. Float
float는 요소 간 수평정렬이다. float 프로퍼티는 layout 구성을 위한 핵심 기술이다. **layout의 가장 큰 목적은 1개 이상의 요소를 원하는 위치에 정렬시키는 것이다.**

**property value**
* none(default): 요소를 떠 있게 하지 않음(기본값)
* right: 요소를 오른쪽으로 이동시킨다.
* left: 요소를 왼쪽으로 이동시킨다.

#### 9.1 정렬
float를 사용하지 않은 블록 요소들은 수직 정렬 된다. float를 사용하면 수평 정렬 된다.
```float: left```: 왼쪽부터 순서대로 수평 정렬
```float right```: 오른쪽부터 순서대로 수평 정렬

> float 프로퍼티는 좌, 우측 정렬만 할 수 있다. 중앙 정렬은 margin 프로퍼티를 사용해야 한다.

```
<!DOCTYPE html>
<html>
<head>
  <style>
    div {
      color: white;
      font-weight: bold;
      font-size: 30px;
      line-height: 50px;
      height: 50px;
      margin: 0 10px;
      padding: 10px;
    }
    .d1 {
      float: left;
      background: red;
    }
    .d2 {
      background: orange;
    }
  </style>
</head>
<body>
  <div class="d1"> float: left; </div>
  <div class="d2"> div </div>
</body>
</html>
```

> float는 본래 다음 요소 위에 올라가 뜨는 것이다. d2의 너비는 d1의 종료시점에서 시작하는 듯 하지만 사실 d1의 시작점부터가 d2의 너비에 속한다.

#### 9.2 float 프로퍼티 관련 문제 해결 방법
##### 1) float 프로퍼티가 선언된 요소와 float 프로퍼티가 선언되지 않은 요소간 margin이 사라지는 문제

```overflow:hidden```  
위 예제를 보면 두 요소는 차례대로 정렬된 것처럼 보이지만 사실은 float 프로퍼티가 선언된 요소가 다음 요소 위에 떠 있는(부유하고 있는) 상태이다. 따라서 두 요소간의 margin은 제대로 표현되지 않는다.

이것은 두번째 요소에 float 프로퍼티를 선언하지 않았기 때문에 발생하는 박스 모델 상의 문제이다. 이 문제를 해결하는 가장 쉬운 방법은 float 프로퍼티를 선언하지 않은 요소(.d2)에 ```overflow: hidden``` 프로퍼티를 선언하는 것이다.

```overflow: hidden``` 프로퍼티는 자식 요소가 부모 요소의 영역보다 클 경우 넘치는 부분을 안보이게 해주는 역할을 하는데 여기서는 float 프로퍼티가 없어서 제대로 표현되지 못하는 요소를 제대로 출력해준다.

##### 2) float 프로퍼티를 가진 자식 요소를 포함하는 부모 요소의 높이가 정상적으로 반영되지 않는 문제

float는 본래 뒤에 오는 요소 위에 떠있도록 하게 하기 위한 프로퍼티이다. 따라서 float는 너비나 높이 계산을 하지 못한다. 

1) ```overflow: hidden;```  
이 문제를 해결하는 가장 쉬운 방법은 float 프로퍼티를 가진 요소의 부모 요소(wrap)에 ```overflow: hidden``` 프로퍼티를 선언하는 것이다. 하지만 이 방법은 부수 효과(부작용, side effect)이 있을 수 있어 권장되는 방법은 아니다.

2) ```::after``` 가상 요소 선택자  
가상 요소 선택자는 CSS2 문법(:after)과 CSS3 문법(::after)이 있는데 IE8까지 지원하는 CSS2 문법을 사용하는 편이 좋다.

3) ```clear: both;```
<div class="clear"></div>  
이 방법을 적용하기 위해서는 **의미 없는 빈 요소**를 만들어야 한다. 이 방법에서 좀 더 발전한 방법이 아래 .clearfix 방법이다.

4) ***```.clearfix:after```*** ***가장 중요***  
미리 clearfix 클래스를 선언해두고, clear:both를 지정하고자 하는 wrap 클래스들에 clearfix 클래스를 추가 적용하면 된다. 의미 없는 빈 요소를 추가로 만들 필요가 없고 단지 class에 추가해주기만 하면 되므로 가장 깔끔하고 간편한 방식이다.
[clearfix reference](https://stackoverflow.com/questions/211383/what-methods-of-clearfix-can-i-use)
> float가 들어올 수 있는 것들은 기본적으로 row 클래스를 사용한다. 

***
### 10. Inheritance & Cascading

#### 10.1 상속(Inheritance)
상속이란 상위(부모, 조상) 요소의 속성(프로퍼티)을 하위(자식, 자손) 요소가 물려 받는 것을 의미한다. 상속 기능이 없다면 각 요소의 Rule set에 프로퍼티를 매번 각각 지정해야 한다. **하지만 모든 프로퍼티가 상속되는 것은 아니다. 프로퍼티 중에는 상속이 되는 것과 되지 않는 것이 있다.**
> 소프트웨어 공학에서는 최대한 **중복**을 줄인다. 그런 의미에서 상속은 매우 유용한 개념이다.

* 크기 계열(box-sizing, layout 계열)은 대부분 상속되지 않는다.
  * width/height
  * margin
  * padding
  * border
  * box-sizing
  * position/float/overflow
  * ...

* 폰트, 색상 계열은 대부분 상속이 된다.
  * font
  * color
  * line-height
  * text-align
  * ...

```
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    .text-red {
      color: red;
      border: 1px solid #bcbcbc;
      padding: 10px;
    }
  </style>
</head>
<body>
  <div class="text-red">
    <h1>Heading</h1>
    <p>Paragraph<strong>strong</strong></p>
    <button>Button</button>
  </div>
</body>
</html>
```

요소에 따라 상속을 받지 않는 것도 존재한다. e.g. button요소

> 개발자 도구상에서 흐린 글씨로 나오는 것은 **상속이 되지 않는 속성(e.g. padding, border)**이라는 의미이다.  

상속되지 않는 경우(상속받지 않는 요소 또는 상속되지 않는 프로퍼티), ```inherit``` 키워드를 사용하여 명시적으로 상속받게 할 수 있다.

```
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <style>
    .text-red {
      color: red;
      border: 1px solid #bcbcbc;
      padding: 10px;
    }
    .text-red button {
      color: inherit;
    }
    .text-red p {
      border: inherit;
      padding: inherit;
    }
  </style>
</head>
<body>
  <div class="text-red">
    <h1>Heading</h1>
    <p>Paragraph<strong>strong</strong></p>
    <button>Button</button>
  </div>
</body>
</html>
```


#### 10.2 캐스캐이딩(Cascading)
요소는 하나 이상의 CSS 선언에 영향을 받을 수 있다. 이때 충돌을 피하기 위해 **CSS 적용 우선순위**가 필요한데 이를 **캐스캐이딩(Cascading Order)**이라고 한다.

* 중요도  
CSS가 **어디에 선언 되었는지**에 따른 우선순위  

* 명시도  
**셀렉터를 얼마나 명확하게 썼는지**  

* 선언 순서  
**선언된 순서**에 따른 우선 순위. 나중에 선언될수록 우선 적용된다.

##### 1) 중요도  
1. head 요소 내의 style 요소
```
<head>
  <style>
    background-color: beige;
    /* 우선순위가 가장 높다. */
  </style>
</head>
<body>
</body>
```
2. head 요소 내의 style 요소 내의 ```@import```문
3. <link>로 연결된 CSS파일
4. <link>로 연결된 CSS파일 내의 ```@import```문
5. 브라우저 디폴트 스타일시트

##### 2) 명시도  

대상이 명확할수록 우선순위가 높아진다.

```!important > 인라인 스타일 > 아이디 선택자 > 클래스/속성/가상 선택자 > 태그 선택자 > 전체 선택자 > 상위 요소에 의해 상속된 속성```

```
<!DOCTYPE html>
<html>
<head>
  <style>
    p        { color: red !important; }
    #thing   { color: blue; }

    div.food { color: chocolate; }
    .food    { color: green; }
    div      { color: orange; }
  </style>
</head>
<body>
  <p id="thing">Will be Red.</p>
  <div class="food">Will be Chocolate.</div>
</body>
</html>
```

#thing > p : 명시도가 id선택자가 더 높다.  
하지만 !important > #thing 이므로 p의 스타일이 적용된다.

##### 3) 선언 순서
선언된 순서에 따라 나중 선언된 스타일이 우선 적용된다.
```
<!DOCTYPE html>
<html>
<head>
  <style>
    p { color: blue; }
    p { color: red; }

    .red { color: red; }
    .blue { color: blue; }
  </style>
</head>
<body>
  <p>Will be RED.</p>
  <p class="blue red">Will be BLUE.</p>
  /* class 적용 순서에는 우선순위가 없다.
     따라서 blue red이든, red blue이든 같은 결과를 낸다.(blue가 적용된다.) */
</body>
</html>
```
***
### 11. Effect

#### 11.1 벤더 프리픽스(Vendor Prefix)
CSS3 표준으로 확정되기 이전(브라우저에 따라 확정되고 나서도 프리픽스를 붙여야만 사용할 수 있는 경우도 있다.) 또는 브라우저 개발사가 실험적으로 제공하는 기능을 사용하기 위해서는 벤더 프리픽스를 사용하여야 한다. (e.g. ```user-select 프로퍼티```)

또한 구형 브라우저를 지원하기 위하여 벤더 프리픽스를 사용하여야 할 필요가 있다.

```
* {
  -webkit-user-select: none;  /* Chrome all / Safari all */
  -moz-user-select: none;     /* Firefox all */
  -ms-user-select: none;      /* IE 10+ */
  user-select: none;          /* Likely future 미래에 브라우저가 발전하여 접두사를 쓸 필요가 없게 되었을 경우를 대비하여 prefix가 없는 코드도 작성해야 한다. */
}
```
많은 브라우저를 위한 벤더 프리픽스를 사용하는 것은 코드의 양을 늘게 하고 또한 브라우저는 거의 매달 업데이트가 이루어지고 있어 불필요한 벤더 프리픽스를 사용할 가능성이 크다. 사용하지 않아도 되는 벤더 프리픽스를 사용하는 것은 성능에도 영향을 주기 때문에 [Prefix Free 라이브러리](http://leaverou.github.io/prefixfree/)를 사용하는 것은 매우 유용한 방법이다.
사용법은 매우 간단하다. Prefix Free 사이트에서 라이브러리를 다운로드하고 include 하기만 하면 이 후에는 벤더 프리픽스없이 모든 CSS를 사용할 수 있다.  
```<script src="prefixfree.min.js"></script>```

#### 11.2 그림자(Shadow)  

텍스트나 요소에 그림자 효과를 부여하기 위한 프로퍼티를 선언한다.

##### 1) text-shadow

```선택자 { text-shadow: Horizontal-offset Vertical-offset Blur-Radius Shadow-Color; }```

***property values***
* Horizontal-offset
* Vertical-offset
* Blur-Radius
* Shadow-Color

##### 2) box-shadow

```선택자 { box-shadow: Inset Horizontal-offset Vertical-offset Blur-Radius Spread Shadow-Color; }```

#### 11.3 그레이디언트(Gradient)

* 선형 그레이디언트(Linear Gradient: goes down/up/left/right/diagonally)
* 방사형 그레이디언트(Radial Gradient: defined by their center)

그레이디언트 구현은 대부분 툴을 사용한다.  
그레이디언트는 브라우저의 속성을 많이 탄다.  


#### 11.4 트랜지션(transition)
어떤 요소의 형태를 변화시키는 것이다. (비틀거나, 돌리거나, 옮기거나, 색상을 바꾸는 등) (이 말은 즉, 부수적인 액션 없이는 프로퍼티를 변화시킬 방법이 없다는 말이다.)
> 어떤 요소에 background red가 지정되어 있을 때, 그 요소에 background blue를 또 지정한다. 이때 hover가 올라오면 두 개의 다른 프로퍼티 값을 모두 지정해주는데 이때 transition으로 액션을 준다.
time을 지정해주면, color가 red->blue로 서서히 변화되는 액션이 된다.

```
<!DOCTYPE html>
<html>
<head>
  <style>
    div {
      width: 100px;
      height: 100px;
      background: red;
    }
    div:hover {
      border-radius: 50%;
      background: blue;
    }
  </style>
</head>
<body>
  <div></div>
</body>
</html>
```
트랜지션(transition)은 CSS 프로퍼티 변경에 따른 표시의 변화를 부드럽게 하기 위해 애니메이션 속도를 조절한다. 즉 프로퍼티 변경이 표시의 변화에 즉시 영향을 미치게 하는 대신 그 프로퍼티의 변화가 일정 시간(duration)에 걸쳐 일어나도록 하는 것이다.
```
<!DOCTYPE html>
<html>
<head>
  <style>
    div {
      width: 100px;
      height: 100px;
      background: red;
      /* 트랜지션 효과: 모든 프로퍼티의 변화를 2초에 걸쳐 전환한다. */
      transition: all 2s;
    }
    div:hover {
      border-radius: 50%;
      background: blue;
    }
  </style>
</head>
<body>
  <div></div>
</body>
</html>
```
위 예제에서는 div 요소에 마우스가 올라갈 때(hover on)와 마우스가 내려올 때(hover off) border-radius, background 프로퍼티의 변경이 발생한다. 그리고 이들 프로퍼티의 변경을 2초에 걸쳐 변화하도록 한 것이다.
>div에 transition을 설정하면 마우스가 올라갈 때(hover on)와 마우스가 내려올 때(hover off) 모두 transition이 발동한다. 하지만 div:hover에 transition을 설정하면 마우스가 올라갈 때(hover on)는 transition이 발동하지만 마우스가 내려올 때(hover off)는 transition이 발동하지 않는다.

```
<!DOCTYPE html>
<html>
<head>
  <style>
    div {
      width: 100px;
      height: 100px;
      background: red;
    }
    div:hover {
      background: blue;
      border-radius: 50%;
      /* hover on에서만 발동한다. */
      transition: all 2s;
    }
  </style>
</head>
<body>
  <div></div>
</body>
</html>
```

**transition은 자동으로 발동되지 않는다.** :hover와 같은 가상 클래스 선택자(Pseudo-Classes) 또는 JavaScript의 onclick 이벤트와 같은 부수적인 액션에 의해 발동한다. 위 예제의 div 요소에 적용된 transition은 이와 같은 부수적 액션없이는 어떤 효과도 볼 수 없다.

***property values***
* transition-property
* transition-duration
* transition-timing-function

##### 1) transition-property
* e.g. ```transition-property: width, background-color;```  
'width와 background-color에 대해서만 트랜지션을 적용한다.'를 의미한다.

모든 css 프로퍼티가 transition의 대상이 될 수 없다. color, font, width 등등 형태, 색깔 크기 등에는 적용되지만, display 속성과 같은 본질을 바꾸는 프로퍼티에는 적용되지 않는다. 

아래는 트랜지션 적용이 가능한 프로퍼티이다. 
```
// Box model
width height max-width max-height min-width min-height
padding margin
border-color border-width border-spacing
// Background
background-color background-position
// 좌표
top left right bottom
// 텍스트
color font-size font-weight letter-spacing line-height
text-indent text-shadow vertical-align word-spacing
// 기타
opacity outline-color outline-offset outline-width
visibility z-index
```

layout에 영향을 주는 트랜지션 효과는 브라우저에 상당한 스트레스를 주므로 피하는 것이 좋다.
```
width height padding margin border
display position float overflow
top left right bottom
font-size font-family font-weight
text-align vertical-align line-height
clear white-space
```

##### 2) transition-duration
```transition-duration``` 프로퍼티는 트랜지션에 일어나는 **지속시간(duration)을 초 단위로 지정**한다. **프로퍼티값을 지정하지 않을 경우 기본값 0s이 적용되어 어떠한 트랜지션 효과도 볼 수 없다.**

다수의 프로퍼티를 적용하는 경우 각각 매칭하여 선언한다.  
아래의 경우, width 프로퍼티는 2초, opacity 프로퍼티는 4초의 지속시간을 갖는다.
```
div {
  transition-property: width, opacity;
  transition-duration: 2s, 4s;
}
```
또한 transition 프로퍼티만으로 표현이 가능하다.
```
div {
  /* shorthand syntax */
  transition: width 2s, opacity 4s;
}
```

##### 3) transition-timing-function
트랜지션 효과의 변화 흐름, 시간에 따른 변화 속도와 같은 일종의 변화의 리듬을 지정한다. (가속 시간)

***property value***
* ```ease(default)```: 기본값. 느리게 시작하여 점점 빨라졌다가 느리지면서 종료한다.
* ```linear```: 시작부터 종료까지 등속 운동(일정한 속도)을 한다.
* ```ease-in```: 느리게 시작한 후 일정한 속도에 다다르면 그 상태로 등속 운동한다.
* ```ease-out```: 일정한 속도의 등속으로 시작해서 점점 느려지면서 종료한다.
* ```ease-in-out```: ease와 비슷하게 느리게 시작하여 느리지면서 종료한다.


##### 4) transition-delay
프로퍼티가 변화한 시점과 트랜지션이 실제로 시작하는 사이에 대기하는 시간을 초 단위로 지정한다. 즉 transition-delay로 대기 사간을 지정하여 프로퍼티가 변화하여도 즉각 트랜지션이 실행되지 않고, 일정 시간 대기한 후 트랜지션이 실행되도록 한다.  

```transition-delay: 1s;```

##### 5) transition-shorthand
모든 트랜지션 프로퍼티를 한번에 지정할 수 있는 shorthand이다. 값을 지정하지 않은 프로퍼티에는 기본값이 지정된다. 지정 방법은 다음과 같다.

```transition: property duration function delay```

> **Notice**
> * 자동 발동되지 않는다.
> * 어디에 위치시킬 것인가
transition 사용에 있어서는 이 두 가지만 유의하면 되는데, 이는 [codepen](https://codepen.io/)를 참고하면 좋다.

#### 11.5 애니메이션(Animation)

***transition VS animation***  
트랜지션은 자동발동 하지 않는 반면 애니메이션은 자동발동하며 무한대로 재생할 수 있다.

애니메이션은 트랜지션보다 브라우저에 부담을 더 많이 준다.

> 트랜지션, 애니메이션 등등은 효과가 얼마나 화려하고 멋있는가보다 더 중요한 것은 어떤 브라우저에서든지 부드럽고 자연스럽게 나타나는 것이다.

애니메이션은 CSS로도, JS로도 구현이 가능하다.  
***그렇다면 어떤 것을 이용해서 만들어야 하는가?***

일반적으로 CSS 애니메이션을 사용하면 기존의 JavaScript 기반 애니메이션 실행과 비교하여 더 나은 렌더링 성능을 제공한다고 알려져 있다. 그러나 경우에 따라서는 JavaScript를 사용하는 것이 나을 수도 있다. jQuery 뿐 아니라 react, angular 등 대부분의 프레임워크가  CSS보다 간편하게 사용할 수 있도록 애니메이션 기능을 제공한다.

* 비교적 작은 효과나 CSS만으로도 충분한 효과를 볼 수 있는 것은 CSS를 사용한다. 예를 들어 요소의 width 변경 애니메이션은 자바스크립트를 사용하는 것보다 훨씬 간편하며 효과적이다.
* 세밀한 제어를 위해서는 자바스크립트 사용이 바람직하다. 예를 들어 바운스, 중지, 일시 중지, 되감기 또는 감속과 같은 고급 효과는 자바스크립트가 훨씬 유용하다.

가장 중요한 것은 **브라우저에서 애니메이션 효과가 부드럽게 실행되는 것**이다. 그리고 애니메이션 효과 작성에 소요되는 시간과 수고이다. 여러 사항들을 고려하여 자바스크립트를 사용하여야 할지 CSS를 사용하여야 할지 결정하여야 한다.

##### 1) @keyframes
CSS 애니메이션과 트랜지션 방식의 주된 차이는 @keyframes rule에 있다. 이 rule을 사용하면 애니메이션의 흐름(sequence) 중의 여러 시점(breakpoint)에서 CSS 프로퍼티값을 지정할 수 있다.

```
@keyframes move {
  /* 애니메이션 시작 시점 */
  from { left: 0; }
  /* 애니메이션 종료 시점 */
  to   { left: 300px; }
}
```
from, to 키워드 대신 %를 사용할 수 있다. 또한 시작과 끝 키프레임 사이에 % 단위로 키프레임을 삽입할 수 있다.
```
@keyframes move {
  0%   { left: 0; }
  50%  { left: 100px; }
  100% { left: 300px; }
}
```
##### 2) animation-name
위 예제를 보면 @keyframes 뒤에 애니메이션을 대표하는 임의의 이름를 부여하였다.
```
@keyframes move {}
```
이 이름을 animation-name 프로퍼티값으로 지정하여 사용하고자 하는 @keyframes rule을 선택한다. 하나 이상의 애니메이션 이름을 지정할 수 있다.
```
<!DOCTYPE html>
<html>
<head>
  <style>
    div {
      position: absolute;
      width: 100px;
      height: 100px;
      animation-name: move, fadeOut, changeColor;
      animation-duration: 5s;
      animation-iteration-count: infinite;
    }
    @keyframes move {
      from { left: 0; }
      to   { left: 300px; }
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to   { opacity: 0; }
    }
    @keyframes changeColor {
      from { background-color: red; }
      to   { background-color: blue; }
    }
  </style>
</head>
<body>
  <div></div>
</body>
</html>
```
##### 3) animation-duration
한 싸이클의 애니메이션에 소요되는 시간을 초 단위로 지정한다.
```
animation-duration: 5s;
```
##### 4) animation-timing-function
##### 5) animation-delay
##### 6) animation-iteration-count
애니메이션 주기의 재생 횟수를 지정한다.(반복 횟수) 기본값은 1이며 infinite로 무한반복 할 수 있다.
##### 7) animation-direction
애니메이션이 종료된 이후 반복될 때 진행하는 방향을 지정한다.
##### 8) animation-fill-mode
애니메이션 미실행 시(대기 또는 종료) 요소의 스타일을 지정한다.
***property values***
* ```none```
  * 대기: 시작 프레임(from)에 설정한 스타일을 적용하지 않고 대기
  * 종료: 애니메이션 실행 전 상태로 원복
* ```forwards```
  * 대기: 시작 프레임(from)에 설정한 스타일을 적용하지 않고 대기
  * 종료: 종료 프레임(to)에 설정한 스타일을 적용한 채로 종료
* ```backwards```
  * 대기: 시작 프레임(from)에 설정한 스타일을 적용하고 대기한다.
  * 종료: 애니메이션 실행 전 상태로 애니메이션 요소의 프로퍼티값을 되돌리고 종료한다.
* ```both```
  * 대기: 시작 프레임(from)에 설정한 스타일을 적용하고 대기한다.
  * 종료: 종료 프레임(to)에 설정한 스타일을 적용하고 종료한다

##### 9) animation-play-state
애니메이션 재생 상태(재생 또는 중지)를 지정한다. 기본값은 running이다.
```
  div:hover {
    background: blue;
      animation-play-state: paused;
    }
    div:active {
      background: yellow;
      animation-play-state: running;
    }
```
***
### 12. Web Font
***
### 13. Layout
***
### 14. Responsive Web Design
***
### 15. Flexbox Layout
***